<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Project3 | 逝川の小屋</title><meta name="author" content="逝川"><meta name="copyright" content="逝川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Hard Transportation Hub王子轩Date: 2024-5-6  Chapter 1: IntroductionBackgroundGiven the map of a country, there could be more than one shortest path between any pair of cities. A transportation hub is a">
<meta property="og:type" content="article">
<meta property="og:title" content="Project3">
<meta property="og:url" content="http://example.com/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report3/index.html">
<meta property="og:site_name" content="逝川の小屋">
<meta property="og:description" content="Hard Transportation Hub王子轩Date: 2024-5-6  Chapter 1: IntroductionBackgroundGiven the map of a country, there could be more than one shortest path between any pair of cities. A transportation hub is a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/head.jpeg">
<meta property="article:published_time" content="2024-12-09T14:45:39.897Z">
<meta property="article:modified_time" content="2024-12-09T14:48:30.546Z">
<meta property="article:author" content="逝川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/head.jpeg"><link rel="shortcut icon" href="/image/head.jpeg"><link rel="canonical" href="http://example.com/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Project3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/jixian.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/head.jpeg" alt="Logo"><span class="site-name">逝川の小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Project3</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Project3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T14:45:39.897Z" title="发表于 2024-12-09 22:45:39">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-09T14:48:30.546Z" title="更新于 2024-12-09 22:48:30">2024-12-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Hard-Transportation-Hub"><a href="#Hard-Transportation-Hub" class="headerlink" title="Hard Transportation Hub"></a>Hard <strong>Transportation Hub</strong></h1><h1 id="王子轩"><a href="#王子轩" class="headerlink" title="王子轩"></a>王子轩</h1><h1 id="Date-2024-5-6"><a href="#Date-2024-5-6" class="headerlink" title="Date: 2024-5-6"></a><strong>Date: 2024-5-6</strong></h1><div style="page-break-after: always;"></div>

<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Given the map of a country, there could be more than one shortest path between any pair of cities. A <strong>transportation hub</strong> is a city that is on no less than <em>k</em> shortest paths (the source and the destination NOT included). </p>
<h3 id="Aim"><a href="#Aim" class="headerlink" title="Aim"></a>Aim</h3><p>Find  for a given pair of cities, the transportation hubs on the way.</p>
<h3 id="What-we-need-to-do"><a href="#What-we-need-to-do" class="headerlink" title="What we need to do"></a>What we need to do</h3><p>The adjacency table is used to construct the graph as a data structure, after reading the data, then Dijkstra’s algorithm is used to find the length of the shortest paths, then the backtracking algorithm is used to find all the shortest paths, and all these paths are stored in an array consisting of a chained list, and then finally traversed to find the transportation hubs as per the requirement.</p>
<h3 id="Why-do-this"><a href="#Why-do-this" class="headerlink" title="Why do this"></a>Why do this</h3><p>Because the comparative data is scattered, I chose to construct the graph as a data structure using an adjacency table. Because I want to find all the shortest paths, so I need to find the length of the shortest paths first, and then I can find all the shortest paths through the backtracking algorithm, in order to find the transportation hub so I need to traverse the previous paths.</p>
<h2 id="Chapter-2-Algorithm-Specification"><a href="#Chapter-2-Algorithm-Specification" class="headerlink" title="Chapter 2: Algorithm Specification"></a>Chapter 2: Algorithm Specification</h2><h3 id="data-structure"><a href="#data-structure" class="headerlink" title="data structure"></a>data structure</h3><ol>
<li><p>vertex structure:</p>
<p> int dist: represents the distance of the node to the start node.</p>
<p> int path: indicates the path of the node, i.e. from the start node to the parent of the current node.</p>
<p> int known: indicates whether the node is known, i.e. whether the shortest path has been calculated.</p>
</li>
<li><p>Edge struct:</p>
<p> int dest: indicates the target node of the edge.</p>
<p> int length: the length of the edge.</p>
<p> struct Edge *next: pointer to other neighboring edges.</p>
</li>
<li><p>PathNode struct:</p>
<p> int vertex: represents the value of the path node.</p>
<p> struct PathNode *next: pointer to the next node.</p>
</li>
<li><p>PathList struct:</p>
<p> PathNode *head: pointer to the first node.</p>
<p> PathList *next: pointer to the next path list.</p>
</li>
<li><p>cnt_onpath Array:</p>
<p> Used to store the number of node visits through the shortest path.</p>
</li>
<li><p>graph array:</p>
<p> Used to store the adjacency table, representing the structure of the graph.</p>
</li>
<li><p>v array:</p>
<p> Used to store information about the node, including the distance from the node to the start node, the path of the node and whether the node is known.</p>
</li>
<li><p>visited array:</p>
<p> Used to record whether a node has been visited.</p>
</li>
<li><p>pathLists array:</p>
<p> Used to store a list of all paths, each path list includes a linked list of the nodes in the path.</p>
</li>
</ol>
<p>These data structures each play different roles in the code for representing the structure of the graph, recording node information, recording paths, and implementing Dijkstra’s algorithm. By using these data structures appropriately, the path problem between nodes in the graph can be solved effectively.</p>
<h3 id="Main-Function"><a href="#Main-Function" class="headerlink" title="Main Function"></a>Main Function</h3><h4 id="sketch"><a href="#sketch" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(Start) --&gt; B(Input thresholds)</span><br><span class="line">B --&gt; C&#123;Loop m times&#125;</span><br><span class="line">C --&gt; D(Read edge information)</span><br><span class="line">D --&gt; E(Create edge)</span><br><span class="line">E --&gt; F(Add edge to graph)</span><br><span class="line">F --&gt; G(Create reverse edge)</span><br><span class="line">G --&gt; H(Add reverse edge to graph)</span><br><span class="line">H --&gt; C</span><br><span class="line">C --&gt; I(Read T)</span><br><span class="line">I --&gt; J(Initialize ans array)</span><br><span class="line">J --&gt; K&#123;Loop T times&#125;</span><br><span class="line">K --&gt; L(Initialize cnt_onpath array)</span><br><span class="line">L --&gt; M(Read src and dst)</span><br><span class="line">M --&gt; N(Initialize visited array)</span><br><span class="line">N --&gt; O(Initialize pathLists)</span><br><span class="line">O --&gt; P(Call Dijkstra&#x27;s algorithm)</span><br><span class="line">P --&gt; Q(Backtrack paths)</span><br><span class="line">Q --&gt; R(Count node visits)</span><br><span class="line">R --&gt; S(Update ans array)</span><br><span class="line">S --&gt; K</span><br><span class="line">K --&gt; T(Print nodes in ans)</span><br><span class="line">T --&gt; K</span><br><span class="line">T --&gt; U(Print None)</span><br><span class="line">U --&gt; K</span><br><span class="line">K --&gt; V&#123;Loop T times&#125;</span><br><span class="line">V --&gt; W(Print newline)</span><br><span class="line">W --&gt; X(End)</span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Function main():</span><br><span class="line">    Declare integer variables n, m, k</span><br><span class="line">    Read the values of n, m, and k from the input</span><br><span class="line"></span><br><span class="line">    Loop m times:</span><br><span class="line">        Declare integer variables len, src, des</span><br><span class="line">        Read the values of src, des, and len from the input</span><br><span class="line"></span><br><span class="line">        Create a new edge with the destination des and length len</span><br><span class="line">        Add the new edge to the list of edges for the source vertex src</span><br><span class="line"></span><br><span class="line">        Create a new edge with the destination src and length len</span><br><span class="line">        Add the new edge to the list of edges for the destination vertex des</span><br><span class="line"></span><br><span class="line">    Declare an integer variable T</span><br><span class="line">    Read the value of T from the input</span><br><span class="line"></span><br><span class="line">    Declare a 2D integer array ans of size 505x505 and initialize it to 0</span><br><span class="line"></span><br><span class="line">    Loop T times:</span><br><span class="line">        Declare integer variables src, dst</span><br><span class="line">        Read the values of src and dst from the input</span><br><span class="line"></span><br><span class="line">        Initialize the counter array cnt_onpath</span><br><span class="line"></span><br><span class="line">        Declare an integer array visited of size 505 and initialize it to 0</span><br><span class="line"></span><br><span class="line">        Create a new pathLists object and initialize its head to a path node with destination dst</span><br><span class="line"></span><br><span class="line">        Call the Dijkstra&#x27;s algorithm function with parameters n, src, and dst</span><br><span class="line"></span><br><span class="line">        Backtrack from the goal node and find all the shortest paths</span><br><span class="line"></span><br><span class="line">        Count the number of visits to nodes on all shortest paths</span><br><span class="line"></span><br><span class="line">        For each node:</span><br><span class="line">            If the number of 1s in its binary representation is greater than or equal to k:</span><br><span class="line">                Set ans[j][i] to 1</span><br><span class="line"></span><br><span class="line">    Loop T times:</span><br><span class="line">        Declare an integer variable flg and set it to 0</span><br><span class="line"></span><br><span class="line">        For each column j in the matrix ans:</span><br><span class="line">            If the element ans[i][j] is equal to 1:</span><br><span class="line">                If flg is 0:</span><br><span class="line">                    Print the element</span><br><span class="line">                    Set flg to 1</span><br><span class="line">                Otherwise:</span><br><span class="line">                    Print a space followed by the element</span><br><span class="line"></span><br><span class="line">        If flg is still 0:</span><br><span class="line">            Print &quot;None&quot;</span><br><span class="line"></span><br><span class="line">        Print a newline character</span><br><span class="line"></span><br><span class="line">    Return 0</span><br></pre></td></tr></table></figure>



<h3 id="dijkstra’s-algorithm-finding-the-length-of-the-shortest-circuit"><a href="#dijkstra’s-algorithm-finding-the-length-of-the-shortest-circuit" class="headerlink" title="dijkstra’s algorithm: finding the length of the shortest circuit"></a>dijkstra’s algorithm: finding the length of the shortest circuit</h3><h4 id="sketch-1"><a href="#sketch-1" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(Start) --&gt; B(Initialize variables)</span><br><span class="line">B --&gt; C(Set source vertex distance to 0)</span><br><span class="line">C --&gt; D(Loop until all vertices are processed)</span><br><span class="line">D --&gt; E(Find vertex with minimum distance)</span><br><span class="line">E --&gt; F(Mark vertex as processed)</span><br><span class="line">F --&gt; G(Update distances and paths of adjacent vertices)</span><br><span class="line">G --&gt; D</span><br><span class="line">D --&gt; H(End)</span><br><span class="line">H --&gt; I(Display result)</span><br><span class="line"></span><br><span class="line">style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style B fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style C fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style D fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style E fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style F fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style G fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style H fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style I fill:#f9f,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode-1"><a href="#Pseudocode-1" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Function dijkstra(n, src, dst):</span><br><span class="line">    // Initialize the distance, path, and known value for all vertices</span><br><span class="line">    For each vertex v[i] from 0 to 504:</span><br><span class="line">        v[i].dist = 1000000000</span><br><span class="line">        v[i].path = -1</span><br><span class="line">        v[i].known = 0</span><br><span class="line"></span><br><span class="line">    // Set the distance of the source vertex to 0</span><br><span class="line">    v[src].dist = 0</span><br><span class="line"></span><br><span class="line">    // The number of vertices that have been processed</span><br><span class="line">    cnt = 0</span><br><span class="line"></span><br><span class="line">    // The current vertex</span><br><span class="line">    V = 0</span><br><span class="line"></span><br><span class="line">    // The algorithm continues to run until all vertices have been processed</span><br><span class="line">    While cnt &lt; n:</span><br><span class="line">        // Find the vertex with the minimum distance</span><br><span class="line">        min_dist = 1000000000</span><br><span class="line">        min_idx = -1</span><br><span class="line"></span><br><span class="line">        For each vertex v[i] from 0 to n-1:</span><br><span class="line">            // If the vertex has not been processed and its distance is less than the minimum distance</span><br><span class="line">            If not v[i].known and v[i].dist &lt; min_dist:</span><br><span class="line">                // Update the minimum distance and index</span><br><span class="line">                min_dist = v[i].dist</span><br><span class="line">                min_idx = i</span><br><span class="line"></span><br><span class="line">        // If no more vertices can be found, break the loop</span><br><span class="line">        If min_idx == -1:</span><br><span class="line">            Break the loop</span><br><span class="line"></span><br><span class="line">        // Update the current vertex</span><br><span class="line">        V = min_idx</span><br><span class="line"></span><br><span class="line">        // Mark the vertex as processed</span><br><span class="line">        v[V].known = 1</span><br><span class="line">        cnt = cnt + 1</span><br><span class="line"></span><br><span class="line">        // Update the distances and paths of the adjacent vertices</span><br><span class="line">        For each edge e in graph[V]:</span><br><span class="line">            w = e.dest</span><br><span class="line"></span><br><span class="line">            If not v[w].known and v[w].dist &gt; v[V].dist + e.length:</span><br><span class="line">                v[w].dist = v[V].dist + e.length</span><br><span class="line">                v[w].path = V</span><br><span class="line"></span><br><span class="line">    Return</span><br></pre></td></tr></table></figure>

<h3 id="backtrackPaths-Backtrack-to-find-all-shortest-paths"><a href="#backtrackPaths-Backtrack-to-find-all-shortest-paths" class="headerlink" title="backtrackPaths :Backtrack to find all shortest paths"></a>backtrackPaths :Backtrack to find all shortest paths</h3><h4 id="sketch-2"><a href="#sketch-2" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Start) --&gt; B(If destination is reached)</span><br><span class="line">B --&gt; C(Add new path to list)</span><br><span class="line">C --&gt; H(End)</span><br><span class="line">B --&gt; D(Iterate through edges)</span><br><span class="line">D --&gt; E(Check distance and node visited)</span><br><span class="line">E --&gt; F(If distance and visited condition met)</span><br><span class="line">F --&gt; G(Add node to current path)</span><br><span class="line">G --&gt; D</span><br><span class="line">E --&gt; D</span><br><span class="line">F --&gt; D</span><br><span class="line">D --&gt; B</span><br><span class="line">D --&gt; H</span><br><span class="line"></span><br><span class="line">style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style B fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style C fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style D fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style E fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style F fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style G fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style H fill:#f9f,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode-2"><a href="#Pseudocode-2" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Function backtrackPaths(src, dst, visited):</span><br><span class="line">    // If the destination is reached, add a new path to the list</span><br><span class="line">    If dst == src:</span><br><span class="line">        pathLists_tail++</span><br><span class="line">        pathLists_tail-&gt;head = NULL</span><br><span class="line">        pathLists_tail-&gt;next = NULL</span><br><span class="line">        flag = 0</span><br><span class="line">        Return</span><br><span class="line"></span><br><span class="line">    // Iterate through the edges of the destination node</span><br><span class="line">    For each edge e in graph[dst]:</span><br><span class="line">        prev = e.dest</span><br><span class="line"></span><br><span class="line">        // If the distance to the destination node is smaller than the previous distance and the node is not visited yet</span><br><span class="line">        If v[prev].dist == v[dst].dist - e.length and not visited[prev]:</span><br><span class="line">            // If the path list is empty and the flag is not set</span><br><span class="line">            If pathLists_tail-&gt;head == NULL and not flag:</span><br><span class="line">                // Copy the path list of the previous node</span><br><span class="line">                oldlist = pathLists_tail - 1</span><br><span class="line">                For each node in oldlist-&gt;head until node-&gt;vertex == dst:</span><br><span class="line">                    // Add the node to the current path</span><br><span class="line">                    addNodeToPath(node-&gt;vertex)</span><br><span class="line"></span><br><span class="line">                // Add the destination node to the current path</span><br><span class="line">                addNodeToPath(dst)</span><br><span class="line">            // If the path list is empty</span><br><span class="line">            Else if pathLists_tail-&gt;head == NULL:</span><br><span class="line">                // Add the destination node to the current path</span><br><span class="line">                addNodeToPath(dst)</span><br><span class="line"></span><br><span class="line">            // Mark the node as visited</span><br><span class="line">            visited[prev] = 1</span><br><span class="line">            // Add the node to the current path</span><br><span class="line">            addNodeToPath(prev)</span><br><span class="line"></span><br><span class="line">            // Recursively call the function with the next node as the destination</span><br><span class="line">            backtrackPaths(src, prev, visited)</span><br><span class="line">            // Unmark the node as visited</span><br><span class="line">            visited[prev] = 0</span><br></pre></td></tr></table></figure>

<h3 id="createPathNode：Used-to-create-new-nodes"><a href="#createPathNode：Used-to-create-new-nodes" class="headerlink" title="createPathNode：Used to create new nodes"></a>createPathNode：Used to create new nodes</h3><h4 id="sketch-3"><a href="#sketch-3" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Start) --&gt; B(Allocate memory for new PathNode)</span><br><span class="line">B --&gt; C(Set vertex value)</span><br><span class="line">C --&gt; D(Set next pointer to NULL)</span><br><span class="line">D --&gt; E(Return pointer to new PathNode)</span><br><span class="line">E --&gt; F(End)</span><br><span class="line"></span><br><span class="line">style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style B fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style C fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style D fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style E fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style F fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode-3"><a href="#Pseudocode-3" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function createPathNode(vertex):</span><br><span class="line">    // Allocate memory for a new PathNode</span><br><span class="line">    node = allocate memory for PathNode</span><br><span class="line">    // Set the vertex value of the new PathNode</span><br><span class="line">    node-&gt;vertex = vertex</span><br><span class="line">    // Set the next pointer of the new PathNode to NULL</span><br><span class="line">    node-&gt;next = NULL</span><br><span class="line">    // Return the pointer to the new PathNode</span><br><span class="line">    Return node</span><br></pre></td></tr></table></figure>

<h3 id="addNodeToPath-Used-to-add-new-nodes-to-the-path"><a href="#addNodeToPath-Used-to-add-new-nodes-to-the-path" class="headerlink" title="addNodeToPath:Used to add new nodes to the path"></a>addNodeToPath:Used to add new nodes to the path</h3><h4 id="sketch-4"><a href="#sketch-4" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Start) --&gt; B(Create new node with given vertex)</span><br><span class="line">B --&gt; C(Check if tail of path list is empty)</span><br><span class="line">C --&gt; D(Set head of path list to new node)</span><br><span class="line">D --&gt; H(End)</span><br><span class="line">C --&gt; E(Set current node pointer)</span><br><span class="line">E --&gt; F(Loop through nodes until next pointer is null)</span><br><span class="line">F --&gt; G(Set current node to next node)</span><br><span class="line">G --&gt; F</span><br><span class="line">F --&gt; E</span><br><span class="line">E --&gt; I(Set next pointer of current node to new node)</span><br><span class="line">I --&gt; H</span><br><span class="line"></span><br><span class="line">style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style B fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style C fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style D fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style E fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style F fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style G fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style H fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style I fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode-4"><a href="#Pseudocode-4" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function addNodeToPath(vertex):</span><br><span class="line">    // Create a new node with the given vertex</span><br><span class="line">    newNode = createPathNode(vertex)</span><br><span class="line">    // If the tail of the path list is empty</span><br><span class="line">    If (pathLists_tail)-&gt;head is NULL:</span><br><span class="line">        // Set the head of the path list to the new node</span><br><span class="line">        (pathLists_tail)-&gt;head = newNode</span><br><span class="line">    // Otherwise</span><br><span class="line">    Else:</span><br><span class="line">        // Set a pointer to the current node</span><br><span class="line">        current = (pathLists_tail)-&gt;head</span><br><span class="line">        // Loop through the nodes until the next pointer is null</span><br><span class="line">        While current-&gt;next is not NULL:</span><br><span class="line">            current = current-&gt;next</span><br><span class="line">        // Set the next pointer of the current node to the new node</span><br><span class="line">        current-&gt;next = newNode</span><br></pre></td></tr></table></figure>

<h3 id="countNodesInPaths-Used-to-count-the-nodes-passed-on-the-path"><a href="#countNodesInPaths-Used-to-count-the-nodes-passed-on-the-path" class="headerlink" title="countNodesInPaths:Used to count the nodes passed on the path"></a>countNodesInPaths:Used to count the nodes passed on the path</h3><h4 id="sketch-5"><a href="#sketch-5" class="headerlink" title="sketch"></a><strong>sketch</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Start) --&gt; B(Loop through each path list)</span><br><span class="line">B --&gt; C(Check if current list is not the tail)</span><br><span class="line">C --&gt; D(Set pointer to the current list)</span><br><span class="line">D --&gt; E(Loop through each node in the path list)</span><br><span class="line">E --&gt; F(Check if current node exists)</span><br><span class="line">F --&gt; G(Check if current node is not the source or destination)</span><br><span class="line">G --&gt; H(Increment count for current node)</span><br><span class="line">H --&gt; F</span><br><span class="line">G --&gt; F</span><br><span class="line">F --&gt; E</span><br><span class="line">E --&gt; C</span><br><span class="line">C --&gt; B</span><br><span class="line">B --&gt; I(End)</span><br><span class="line"></span><br><span class="line">style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style B fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style C fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style D fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style E fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style F fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style G fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style H fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">style I fill:#f9f,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure>

<h4 id="Pseudocode-5"><a href="#Pseudocode-5" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function countNodesInPaths(n, src, des):</span><br><span class="line">    // Loop through each path list</span><br><span class="line">    For each list in pathLists:</span><br><span class="line">        // Loop through each node in the path list</span><br><span class="line">        For each node in list:</span><br><span class="line">            // If the node is not the source or destination node</span><br><span class="line">            If node.vertex is not equal to src and node.vertex is not equal to des:</span><br><span class="line">                // Increment the count for the current node</span><br><span class="line">                cnt_onpath[node.vertex] += 1</span><br></pre></td></tr></table></figure>

<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><table>
<thead>
<tr>
<th align="left">test case</th>
<th>aim</th>
<th>Expected results</th>
<th>Actual results</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10 16 2<br/>1 2 1<br/>1 3 1<br/>1 4 2<br/>2 4 1<br/>2 5 2<br/>3 4 1<br/>3 0 1<br/>4 5 1<br/>4 6 2<br/>5 6 1<br/>7 3 2<br/>7 8 1<br/>7 0 3<br/>8 9 1<br/>9 0 2<br/>0 6 2<br/>3<br/>1 6<br/>7 0<br/>5 5</td>
<td>Sample example given in the title, tests include the case with and without a traffic hub</td>
<td>2 3 4 5<br/>None<br/>None</td>
<td>2 3 4 5<br/>None<br/>None</td>
</tr>
<tr>
<td align="left">5 6 2  <br/>0 1 1<br/>0 2 2<br/>1 3 3<br/>2 3 1<br/>2 4 4<br/>3 4 2<br/>3<br/>0 3<br/>0 4<br/>1 4</td>
<td>Test all three with no traffic hubs</td>
<td>None<br/>None<br/>None</td>
<td>None<br/>None<br/>None</td>
</tr>
<tr>
<td align="left">20 38 4  <br/>0 1 1  <br/>0 2 1  <br/>0 3 2  <br/>1 2 1  <br/>1 4 2  <br/>1 5 3  <br/>2 3 1  <br/>2 6 3  <br/>3 4 1  <br/>3 7 2  <br/>4 5 1  <br/>4 8 3  <br/>4 9 4  <br/>5 6 2  <br/>5 10 3  <br/>6 7 1  <br/>6 11 4  <br/>7 8 2  <br/>7 12 3  <br/>8 9 1  <br/>8 13 4  <br/>9 10 2  <br/>9 14 3  <br/>10 11 1  <br/>10 15 4  <br/>11 12 2  <br/>11 16 3  <br/>12 13 1  <br/>12 17 4  <br/>13 14 2  <br/>13 18 3  <br/>14 15 1  <br/>14 19 2  <br/>15 16 3  <br/>16 17 2  <br/>16 18 3  <br/>17 19 1  <br/>18 19 2  <br/>10  <br/>0 19  <br/>1 18  <br/>2 17  <br/>3 16  <br/>4 15  <br/>5 14  <br/>6 13  <br/>7 12  <br/>8 11  <br/>9 10</td>
<td>Testing very complex samples</td>
<td>2 3 4 7 8 9 12 14<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None</td>
<td>2 3 4 7 8 9 12 14<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None<br/>None</td>
</tr>
</tbody></table>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4: Analysis and Comments"></a>Chapter 4: Analysis and Comments</h2><h3 id="Time-Complexity-Analysis"><a href="#Time-Complexity-Analysis" class="headerlink" title="Time Complexity Analysis:"></a>Time Complexity Analysis:</h3><p>The time complexity of Dijkstra’s algorithm is O(V^2), where V is the number of vertices. In this code, an adjacency table is used to represent the graph and hence the time complexity of Dijkstra’s algorithm is O(V^2).</p>
<p>The process of backtracking paths involves traversing all the shortest paths, so the time complexity depends on the number of shortest paths. In the worst case, all the nodes are on the shortest paths and hence the time complexity of backtracking path is O(V).</p>
<p>The process of counting the number of nodes involves traversing all the nodes on the shortest path and hence the time complexity also depends on the number of shortest paths. In the worst case, all the nodes are on the shortest path and hence the time complexity of counting the number of nodes is O(V).</p>
<p>Therefore, the time complexity of the overall code is O(V^2).</p>
<h3 id="Space-complexity-analysis"><a href="#Space-complexity-analysis" class="headerlink" title="Space complexity analysis:"></a>Space complexity analysis:</h3><p>The space complexity of an adjacency table is O(V + E), where V is the number of vertices and E is the number of edges. In this code, an adjacency table is used to represent the graph, so the space complexity is O(V + E).</p>
<p>Additional vertex structures are used to store node information, and PathNode and PathList structures to store path information. Therefore, the additional space complexity is O(V).</p>
<p>Therefore, the overall space complexity of the code is O(V + E).</p>
<h3 id="Possible-further-improvements"><a href="#Possible-further-improvements" class="headerlink" title="Possible further improvements:"></a>Possible further improvements:</h3><p>Optimized Search Algorithm: The time complexity of Dijkstra’s algorithm is its main bottleneck. Consider using other more efficient algorithms such as A* search (which can achieve O(b^d) when heuristic information is available, where b is the branching factor and d is the average of the heuristic functions, and is usually faster than Dijkstra’s O(V^2)), or use a priority queue (e.g., binary heap) to optimize the path search process.</p>
<p>Use of parallel computation: If the problem can be processed in parallel, e.g., working independently on multiple paths, consider using multithreading or multiprocessing to speed up the search.</p>
<p>Pruning strategies: When backtracking paths, pruning techniques can be used, such as stopping the search as soon as a shorter path is found, to avoid unnecessary computation.</p>
<p>Data structure optimization: If the edges of the graph are sparse and the weights of the edges are evenly distributed, you can consider using adjacency matrix instead of adjacency table, but the space complexity will be higher.</p>
<h3 id="Appendix-Source-Code-in-C"><a href="#Appendix-Source-Code-in-C" class="headerlink" title="Appendix: Source Code (in C)"></a>Appendix: Source Code (in C)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the counter array</span></span><br><span class="line"><span class="type">int</span> cnt_onpath[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition of an adjacency table node that treats edges as nodes</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Distance of the node from the starting node</span></span><br><span class="line">    <span class="type">int</span> dist;</span><br><span class="line">    <span class="comment">// The path of the node</span></span><br><span class="line">    <span class="type">int</span> path;</span><br><span class="line">    <span class="comment">// A flag to check if the distance of the node has been calculated</span></span><br><span class="line">    <span class="type">int</span> known;</span><br><span class="line">&#125; vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dest;          <span class="comment">// Target vertex</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">// Length of the edge</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">next</span>;</span> <span class="comment">// Pointer to other neighboring edges</span></span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new edge and connects it to the end of the list</span></span><br><span class="line"><span class="comment">//Creates a new edge with a given destination and length</span></span><br><span class="line">Edge *<span class="title function_">createEdge</span><span class="params">(<span class="type">int</span> dest, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Allocates memory for a new edge</span></span><br><span class="line">    Edge *edge = (Edge *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">    <span class="comment">//Sets the destination of the edge</span></span><br><span class="line">    edge-&gt;dest = dest;</span><br><span class="line">    <span class="comment">//Sets the length of the edge</span></span><br><span class="line">    edge-&gt;length = length;</span><br><span class="line">    <span class="comment">//Sets the next edge to NULL</span></span><br><span class="line">    edge-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//Returns the new edge</span></span><br><span class="line">    <span class="keyword">return</span> edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void dijkstra(int n, int src, int dst) is a function that calculates the shortest path between two nodes in a graph using Dijkstra&#x27;s algorithm</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> dst)</span>;</span><br><span class="line"><span class="comment">// void cnt(vertex *v, int src, int dst, int n, int k) is a function that counts the number of shortest paths between two nodes in a graph</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cnt</span><span class="params">(vertex *v, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> n, <span class="type">int</span> k)</span>;</span><br><span class="line"></span><br><span class="line">Edge *graph[<span class="number">505</span>]; <span class="comment">// adjacency table</span></span><br><span class="line">vertex v[<span class="number">505</span>];    <span class="comment">// Array of vertices</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A list of nodes used to store paths</span></span><br><span class="line"><span class="comment">// A structure to hold a path from a vertex to the next</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PathNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// The vertex this pathnode leads to</span></span><br><span class="line">    <span class="type">int</span> vertex;</span><br><span class="line">    <span class="comment">// The next pathnode in the path</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PathNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; PathNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Used to keep a list of all paths</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PathList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// pointer to the first node in the list</span></span><br><span class="line">    PathNode *head;</span><br><span class="line">    <span class="comment">// pointer to the next PathList in the list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PathList</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; PathList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new path node</span></span><br><span class="line"><span class="comment">//This function creates a new PathNode with the specified vertex value and returns a pointer to it.</span></span><br><span class="line">PathNode *<span class="title function_">createPathNode</span><span class="params">(<span class="type">int</span> vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Allocate memory for a new PathNode</span></span><br><span class="line">    PathNode *node = (PathNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PathNode));</span><br><span class="line">    <span class="comment">//Set the vertex value of the new PathNode</span></span><br><span class="line">    node-&gt;vertex = vertex;</span><br><span class="line">    <span class="comment">//Set the next pointer of the new PathNode to NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//Return the pointer to the new PathNode</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array to store path lists</span></span><br><span class="line">PathList pathLists[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// Pointer to the head of the path list</span></span><br><span class="line">PathList *pathLists_head = pathLists;</span><br><span class="line"><span class="comment">// Pointer to the tail of the path list</span></span><br><span class="line">PathList *pathLists_tail = pathLists;</span><br><span class="line"><span class="type">int</span> desti;</span><br><span class="line"><span class="comment">// Function to add a node to the end of the path list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addNodeToPath</span><span class="params">(<span class="type">int</span> vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new node with the given vertex</span></span><br><span class="line">    PathNode *newNode = createPathNode(vertex);</span><br><span class="line">    <span class="comment">// If the tail of the path list is empty</span></span><br><span class="line">    <span class="keyword">if</span> (!(pathLists_tail)-&gt;head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set the head of the path list to the new node</span></span><br><span class="line">        (pathLists_tail)-&gt;head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set a pointer to the current node</span></span><br><span class="line">        PathNode *current = (pathLists_tail)-&gt;head;</span><br><span class="line">        <span class="comment">// Loop through the nodes until the next pointer is null</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set the next pointer of the current node to the new node</span></span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Backtrack from a given vertex and find all shortest paths</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrackPaths</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> *visited)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the destination is reached, add a new path to the list</span></span><br><span class="line">    <span class="keyword">if</span> (dst == src)</span><br><span class="line">    &#123;</span><br><span class="line">        pathLists_tail++;</span><br><span class="line">        pathLists_tail-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        pathLists_tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through the edges of the destination node</span></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = graph[dst]; e != <span class="literal">NULL</span>; e = e-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> prev = e-&gt;dest;</span><br><span class="line">        <span class="comment">// If the distance to the destination node is smaller than the previous distance and the node is not visited yet</span></span><br><span class="line">        <span class="keyword">if</span> (v[prev].dist == v[dst].dist - e-&gt;length &amp;&amp; !visited[prev])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If the path list is empty and the flag is not set</span></span><br><span class="line">            <span class="keyword">if</span> (pathLists_tail-&gt;head == <span class="literal">NULL</span> &amp;&amp; !flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Copy the path list of the previous node</span></span><br><span class="line">                PathList *oldlist = pathLists_tail - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (PathNode *node = oldlist-&gt;head; node-&gt;vertex != dst; node = node-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Add the node to the current path</span></span><br><span class="line">                    addNodeToPath(node-&gt;vertex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Add the destination node to the current path</span></span><br><span class="line">                addNodeToPath(dst);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If the path list is empty</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pathLists_tail-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Add the destination node to the current path</span></span><br><span class="line">                addNodeToPath(dst);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Mark the node as visited</span></span><br><span class="line">            visited[prev] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Add the node to the current path</span></span><br><span class="line">            addNodeToPath(prev);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recursively call the function with the next node as the destination</span></span><br><span class="line">            backtrackPaths(src, prev, visited);</span><br><span class="line">            <span class="comment">// Unmark the node as visited</span></span><br><span class="line">            visited[prev] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Count the number of visits to nodes on all shortest paths</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countNodesInPaths</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> des)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Loop through each path list</span></span><br><span class="line">    <span class="keyword">for</span> (PathList *<span class="built_in">list</span> = pathLists_head; <span class="built_in">list</span> != pathLists_tail; <span class="built_in">list</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Loop through each node in the path list</span></span><br><span class="line">        <span class="keyword">for</span> (PathNode *node = <span class="built_in">list</span>-&gt;head; node; node = node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If the node is not the source or destination node</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;vertex != des &amp;&amp; node-&gt;vertex != src)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Increment the count for the current node</span></span><br><span class="line">                cnt_onpath[node-&gt;vertex]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling backtrackPaths and countNodesInPaths in the main function</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k); <span class="comment">// Enter the thresholds for the number of vertices, edges, and transportation hubs respectively</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> src, des;</span><br><span class="line">        <span class="comment">// Read the source and destination vertices, and the length of the edge.</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;src);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;des);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">        <span class="comment">// Create a new edge with the given source, destination, and length.</span></span><br><span class="line">        Edge *edge = createEdge(des, len);</span><br><span class="line">        <span class="comment">// Add the new edge to the existing list of edges for the source vertex.</span></span><br><span class="line">        edge-&gt;next = graph[src];</span><br><span class="line">        graph[src] = edge; <span class="comment">// Add this edge to the first one in the adjacency table.</span></span><br><span class="line">        <span class="comment">// Since this is an undirected graph, we also need to add a reverse edge</span></span><br><span class="line">        <span class="comment">// So we create a new edge with the source and destination reversed, and add it to the list of edges for the destination vertex.</span></span><br><span class="line">        edge = createEdge(src, len);</span><br><span class="line">        edge-&gt;next = graph[des];</span><br><span class="line">        graph[des] = edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="type">int</span> ans[<span class="number">505</span>][<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// Initialize the answer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; T; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Initialize the counter array</span></span><br><span class="line">        <span class="type">int</span> src, dst;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">505</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt_onpath[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;src, &amp;dst);</span><br><span class="line">        desti = dst;</span><br><span class="line">        <span class="comment">// Used to mark if a node was visited during backtracking</span></span><br><span class="line">        <span class="type">int</span> visited[<span class="number">505</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use to keep a list of all shortest paths</span></span><br><span class="line">        pathLists_tail = pathLists;</span><br><span class="line">        pathLists-&gt;head = createPathNode(dst);</span><br><span class="line">        pathLists-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call Dijkstra&#x27;s algorithm</span></span><br><span class="line">        dijkstra(n, src, dst);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Backtrack from the goal node and find all the shortest paths</span></span><br><span class="line">        backtrackPaths(src, dst, visited);</span><br><span class="line">        <span class="comment">// Count the number of visits to nodes on all shortest paths</span></span><br><span class="line">        countNodesInPaths(n, src, dst);</span><br><span class="line">        <span class="comment">// for each node, if the number of 1s in its binary representation is greater than or equal to k, set ans[i][j] = 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt_onpath[i] &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for each test case, print the nodes that ans[i][j] is equal to 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag is used to check if an element has been printed</span></span><br><span class="line">        <span class="type">int</span> flg = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// iterate through the columns of the matrix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if the element exists in the matrix</span></span><br><span class="line">            <span class="keyword">if</span> (ans[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if flag is 0, print the element</span></span><br><span class="line">                <span class="keyword">if</span> (!flg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, j);</span><br><span class="line">                    <span class="comment">// set flag to 1</span></span><br><span class="line">                    flg = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// otherwise, print the element with a space before it</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if flag is still 0, that means no element was printed, so print &quot;None&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!flg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// print a newline character</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Implement the dijkstra algorithm</span></span><br><span class="line">    <span class="comment">// Initialize the distance, path, and known value for all vertices</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">505</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i].dist = <span class="number">1000000000</span>;</span><br><span class="line">        v[i].path = <span class="number">-1</span>;</span><br><span class="line">        v[i].known = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the distance of the source vertex to 0</span></span><br><span class="line">    v[src].dist = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The number of vertices that have been processed</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The current vertex</span></span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">// The algorithm continues to run until all vertices have been processed</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find the vertex with the minimum distance</span></span><br><span class="line">        <span class="type">int</span> min_dist = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="type">int</span> min_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If the vertex has not been processed and its distance is less than the minimum distance</span></span><br><span class="line">            <span class="keyword">if</span> (!v[i].known &amp;&amp; v[i].dist &lt; min_dist)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Update the minimum distance and index</span></span><br><span class="line">                min_dist = v[i].dist;</span><br><span class="line">                min_idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If no more vertices can be found, break the loop</span></span><br><span class="line">        <span class="keyword">if</span> (min_idx == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Update the current vertex</span></span><br><span class="line">        V = min_idx;</span><br><span class="line">        <span class="comment">// Mark the vertex as processed</span></span><br><span class="line">        v[V].known = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// Update the distances and paths of the adjacent vertices</span></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = graph[V]; e != <span class="literal">NULL</span>; e = e-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w = e-&gt;dest;</span><br><span class="line">            <span class="keyword">if</span> (!v[w].known &amp;&amp; v[w].dist &gt; v[V].dist + e-&gt;length)</span><br><span class="line">            &#123;</span><br><span class="line">                v[w].dist = v[V].dist + e-&gt;length;</span><br><span class="line">                v[w].path = V;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h3><p>I hereby declare that all the work done in this project titled “<strong>Transportation Hub</strong>“ is of my independent effort.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">逝川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report3/">http://example.com/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">逝川の小屋</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/head.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/09/%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93/" title="三位一体"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">三位一体</div></div><div class="info-2"><div class="info-item-1"> 我面试的是机器人工程  面试流程：多面多 我记得是五个人一起  自我介绍 中文  英文口语 我被问到：请你介绍一个你经历过的志愿者活动，并分享感想  考官提问 按照序号轮流回答（对于末位很不利 我就是因为末位发言 导致我的想法被别人说完了） 问题 请你介绍卷积神经网络 用什么原理或技术实现乒乓球机器人 请你证明勾股定理（方法不得重复） 针对自我介绍的内容提问（项目经历 获奖等）    多面一（大概5分钟，五六个人面你一个） 自我介绍（同上））  技巧 一般最简单的结构就是开场白-分1-分2-分3-结尾。内容主要是把自己和专业的契合度说出来。像工科的话比如之前做过什么项目 得过什么奖项 自己学习过什么软件 有什么特殊经历比如竞赛 技术分数特别高也可以说。提前准备对于自己闪光点有可能被问到的题目，在自我介绍里面针对自己闪光点做一个hook，吸引面试官提问吧，然后就可以直接背稿了。实在攒不到什么闪光点,个性爱好也许也能凑凑字数？但可能没啥用（） hook举例： “我对于前沿技术很感兴趣，空余时候经常关注前沿技术进展”-&gt;吸引面试官提问“你了解过什么前沿技术...</div></div></div></a><a class="pagination-related" href="/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report2/" title="Project2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Project2</div></div><div class="info-2"><div class="info-item-1">Hard Autograd for Algebraic Expressionsauthor:王子轩Date: 2024-4-6  Chapter 1: IntroductionBackgroundThe application of automatic differentiation technology in frameworks such as torch and tensorflow has greatly facilitated people’s implementation and training of deep learning algorithms based on backpropagation.  AimNow, we hope to implement an automatic differentiation program for algebraic expressions. What we need to dofirst build a binary tree according to the given expression, then...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">逝川</div><div class="author-info-description">村长,开饭了吗 o.O</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hard-Transportation-Hub"><span class="toc-number">1.</span> <span class="toc-text">Hard Transportation Hub</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%8B%E5%AD%90%E8%BD%A9"><span class="toc-number">2.</span> <span class="toc-text">王子轩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Date-2024-5-6"><span class="toc-number">3.</span> <span class="toc-text">Date: 2024-5-6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-Introduction"><span class="toc-number">3.1.</span> <span class="toc-text">Chapter 1: Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Background"><span class="toc-number">3.1.1.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aim"><span class="toc-number">3.1.2.</span> <span class="toc-text">Aim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-we-need-to-do"><span class="toc-number">3.1.3.</span> <span class="toc-text">What we need to do</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-do-this"><span class="toc-number">3.1.4.</span> <span class="toc-text">Why do this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Algorithm-Specification"><span class="toc-number">3.2.</span> <span class="toc-text">Chapter 2: Algorithm Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#data-structure"><span class="toc-number">3.2.1.</span> <span class="toc-text">data structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Main-Function"><span class="toc-number">3.2.2.</span> <span class="toc-text">Main Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra%E2%80%99s-algorithm-finding-the-length-of-the-shortest-circuit"><span class="toc-number">3.2.3.</span> <span class="toc-text">dijkstra’s algorithm: finding the length of the shortest circuit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch-1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode-1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backtrackPaths-Backtrack-to-find-all-shortest-paths"><span class="toc-number">3.2.4.</span> <span class="toc-text">backtrackPaths :Backtrack to find all shortest paths</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch-2"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode-2"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createPathNode%EF%BC%9AUsed-to-create-new-nodes"><span class="toc-number">3.2.5.</span> <span class="toc-text">createPathNode：Used to create new nodes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch-3"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode-3"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addNodeToPath-Used-to-add-new-nodes-to-the-path"><span class="toc-number">3.2.6.</span> <span class="toc-text">addNodeToPath:Used to add new nodes to the path</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch-4"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode-4"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countNodesInPaths-Used-to-count-the-nodes-passed-on-the-path"><span class="toc-number">3.2.7.</span> <span class="toc-text">countNodesInPaths:Used to count the nodes passed on the path</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sketch-5"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">sketch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pseudocode-5"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">Pseudocode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-Testing-Results"><span class="toc-number">3.3.</span> <span class="toc-text">Chapter 3: Testing Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-Analysis-and-Comments"><span class="toc-number">3.4.</span> <span class="toc-text">Chapter 4: Analysis and Comments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Time-Complexity-Analysis"><span class="toc-number">3.4.1.</span> <span class="toc-text">Time Complexity Analysis:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Space-complexity-analysis"><span class="toc-number">3.4.2.</span> <span class="toc-text">Space complexity analysis:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Possible-further-improvements"><span class="toc-number">3.4.3.</span> <span class="toc-text">Possible further improvements:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Appendix-Source-Code-in-C"><span class="toc-number">3.4.4.</span> <span class="toc-text">Appendix: Source Code (in C)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Declaration"><span class="toc-number">3.4.5.</span> <span class="toc-text">Declaration</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93/" title="三位一体">三位一体</a><time datetime="2024-12-09T14:46:48.886Z" title="发表于 2024-12-09 22:46:48">2024-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report3/" title="Project3">Project3</a><time datetime="2024-12-09T14:45:39.897Z" title="发表于 2024-12-09 22:45:39">2024-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report2/" title="Project2">Project2</a><time datetime="2024-12-09T14:45:39.890Z" title="发表于 2024-12-09 22:45:39">2024-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Report1/" title="Project1">Project1</a><time datetime="2024-12-09T14:45:39.882Z" title="发表于 2024-12-09 22:45:39">2024-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/Bonus2/" title="Bonus2">Bonus2</a><time datetime="2024-12-09T14:45:39.881Z" title="发表于 2024-12-09 22:45:39">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By 逝川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>